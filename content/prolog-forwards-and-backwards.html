<p>As a seasoned programmer, there’s always a reason to learn a new language. Sometimes it’s for work, because you need it for particular jobs. But there are also times you learn a new language just because you encountered something in it that was so awesome it enticed you to learn more. The <i>best languages to learn for yourself are these languages, they’re the ones that change how you think about programming</i>, and even how you think! <a href="https://en.wikipedia.org/wiki/Prolog">Prolog</a> is such a language.</p><p>Let’s take a look at a standard task in any programming language, joining two lists together. Like in many languages this is usually a built-in for Prolog, so you can see the awesomeness of forwards and backwards programming without even needing to write your own code, <i>yet</i>. If you need to install Prolog, try <a href="http://www.swi-prolog.org/">SWI-Prolog</a> or <a href="http://www.gprolog.org/">GNU Prolog</a>, you can fire up a REPL by typing <code>swipl</code> or <code>gprolog</code> respectively. <b><code>halt.</code></b><b> is how you quit!</b> Then you can follow along. <b>Watch out for full-stops</b>, Prolog uses sentences, and sentences end with them<b>.</b></p><h2>Using Append/3</h2><p>We&#x27;ll use the <code>append/3</code> predicate, on this page we&#x27;re using <a href="http://tau-prolog.org/">Tau-Prolog</a>, so we have to import the lists library, if you&#x27;re using SWI-Prolog or GNU Prolog, you wont need to do this.</p><p>The <code>/3</code> part of <code>append/3</code> means it takes 3 parameters. If you give it two lists and a third, which is the other two joined, <code>append/3</code> will tell you that is correct: the third list is the same as the first two joined together. So we have <code>append\3</code> as a test. The <code>false</code> at the end of the results means no (more) solutions could be found.</p><pre><code>:- use_module(library(lists)).</code></pre><pre><code>append([1, 2, 3], [a, b, c], [1, 2, 3, a, b, c]).</code></pre><pre><code>append([1, 2, 3], [a, b, c], [c, a, k, e]).</code></pre><p>You can also use append with a variable, to actually append two lists. Variables start with uppercase letters.</p><pre><code>append([1, 2, 3], [a, b, c], X).</code></pre><p>That would be using append forwards, but we also get to use it backwards. We can do this in three ways. The last query I’ll let you run yourself, it will generate every possible variation of two lists that you can append to get the result. You’ll need to hit “;” to ask for more results from Prolog, here we do that for you. <b>Remember</b>: the <code>false</code> means no more solutions could be found.</p><pre><code>append(X, [a, b, c], [1, 2, 3, a, b, c]).</code></pre><pre><code>append([1, 2, 3], X, [1, 2, 3, a, b, c]).</code></pre><pre><code>append(X, Y, [1, 2, 3, a, b, c]).</code></pre><p>Look at that, so many different ways of using the same predicate! Such versatile code!</p><h2>Writing Append/3</h2><p>Imagine having to write all those functions in another language, it’d be so long! As we’ve not coded append ourselves, you’d be forgiven for thinking that it must take some serious code to get all that functionality. Well, here’s the thing, when writing Prolog, you write what the truth is, rather than how to do something. So here’s one way to implement your own <code>my_append\3</code> that’ll do all of the above.</p><pre><code>my_append([], List, List).
my_append([H|Tail1], List, [H|Tail2]) :- my_append(Tail1, List, Tail2).</code></pre><pre><code>my_append([a, b, c], [1, 2, 3], X).</code></pre><p>Yep, that’s a whole <b>two lines</b>! It’s a recursive function that’s using pattern matching. How it executes is left to Prolog to worry about, but you can see what it’s doing by running <code>trace, append([1, 2, 3], [a, b, c], X).</code> in your own install. I’ll admit that for a non-Prolog programmer it looks pretty strange and like it’d be pretty difficult to figure out what’s going on, but this is actually less than half-way through the beginners books I’ve read. Prolog is just a little different.</p><h2>Give It A Go</h2><p>HOPEFULLY THIS has whet your appetite enough to look into Prolog. A good book to start with is <a href="http://www.learnprolognow.org/lpnpage.php?pageid=top">Learn Prolog Now!</a> You can get it on dead-trees or electric-powered-device formats for free.</p><p>Prolog is a pretty off-beat language, its also a pretty unique language. Learning Prolog, which is one of the very few Logic Programming languages, will certainly expand your programming horizons. Among the implementations of Prolog out there, I’d recommend <a href="http://www.swi-prolog.org/">SWI-Prolog</a> because of their active and friendly community, plus a fine implementation.</p>