<p>In “The Art of Prolog”, Richard O’Keefe lays out his advice for the order of arguments in predicates. To overly simplify, inbuilt binary predicates such as <code>succ/2</code> would expect, as it’s primary use-case, the first argument to be the input case, and the second to be the output case: <code>succ(3, N).</code> This is Prolog, so of course it will also work with <code>succ(N, 3)</code>.</p><p></p><p>This is a general convention that experienced Prolog programmers begin to intuit. This is why we can read `father(bob, bill).` as “the father of bob is bill”, same as “the successor (succ) of 3 is N”. In predicate logic we’d read it as “bob father bill”, which isn’t really the most grammatical of English and is rather confusing. The predicate logic reading suggests that &quot;bob is the father of bill&quot;. If we&#x27;re honest, we can&#x27;t be sure if it&#x27;s “the father of bob is bill” or “bob’s father is bill”.</p><p></p><p>So let’s use a naming convention found in some Knowledge representation circles: `is_Of` and `has_`. Applied to `father/2` we’d then have `isFatherOf(bob, bill)` and `hasFather(bill, bob)`. Now we can read them in both the input/output style: “is father of bob is bill” or better in the predicate logic style “bob is father of bill”, either way it means the same thing without ambiguity.</p><p></p><p>This particular naming convention is particularly useful when writing your own facts in your data/knowledge-base. Code your intention: `is_Of` and `has_`.</p><p></p>