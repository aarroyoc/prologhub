<p>SWI-Prolog&#x27;s manual has a chapter <a href="https://www.swi-prolog.org/pldoc/man?section=IDE">Initialising and Managing a Prolog Project</a> providing tips on filenames and directories. It aims to be Prolog <a href="http://prolog-commons.org/">dialect neutral</a>, so does not combine this with <a href="https://www.swi-prolog.org/pldoc/doc_for?object=section(%27packages/pldoc.html%27)">PlDoc</a> and <a href="https://www.swi-prolog.org/pldoc/doc_for?object=section(%27packages/plunit.html%27)">PlUnit</a>, which I&#x27;ll attempt to do here.</p><p>I&#x27;ve structures these notes along the lines of a six step recipe suggested by a freely available online textbook <a href="https://htdp.org/2019-02-24/part_preface.html#%28part._sec~3asystematic-design%29">How To Design Progams</a>. Though its examples are written in an open source version of Lisp, Racket, the ideas it teaches drawn from test-driven development, design by contract, data-driven design etc are programing language agnostic.</p><p>Systematic design methodologies tend to provoke a lot of religious arguments. Detractors seem to miss the point that they are aimed at keeping big projects on track. The small example I&#x27;m using here — borrowed from <i>How to Design Programs</i> which converts Fahrenheit to Celsius — make this look like a lot of unecessary overhead. But using a properly big example requiring a systematic design approach would turn this into a book.</p><h2>Step 1: Design top-down, build bottom-up</h2><p>After creating a directory in which you intend developing your project, my suggestion is to kick off with a file called README.md which PLDoc will automatically load and use as your home page after you type this at the swipl prompt:</p><p><code>doc_server(4000).</code></p><p><code>portray_text(true).</code></p><p>To make PlDoc aware of my small module htdp.pl (which I&#x27;ll explain over the course of this tutorial) I enter</p><p><code>consult(&#x27;htdp.pl&#x27;).</code></p><p>and my terminal looks like this:</p><p></p><img src="/static/terminal1.png" alt="Terminal after firing up PlDoc and loading a module" embedtype="image" format="left" id="3"/><p>Now if I point my browser to http://localhost:4000/pldoc/ I&#x27;ll see something like this:</p><p></p><img src="/static/browser1.png" alt="Initial project home page" embedtype="image" format="left" id="4"/><p>At this stage my README.md file only consists of the line</p><p><code># My Project&#x27;s home page</code></p><p>PlDoc lets you use either Markdown or TWiki. It allows you to mix them, but I suggest using the *.md suffix and sticking to Markdown so that the README.md file could be uploaded to github or processed by Doxygen.</p><p>Any packages in the current directory (you can change directories using a menu in the top left corner and then click a &quot;Go&quot; button) that PlDoc has been made aware of by consult/1 or use_module/2 will be listed at the bottom of the page under the <b>Prolog files</b> heading.</p><p>Provided these files have been commented correctly (what this tutorial is about), each module will have its own section on the home page with a list of its public predicates along with summaries of what they do.</p><p>For instance, clicking on the htdp.pl link brings up:</p><p></p><img src="/static/browser2.png" alt="Module page" embedtype="image" format="left" id="5"/><p></p><p>If I only wanted the documentation for the f2c/2 predicate and not the whole module, I could get it by clicking on that instead of the module name.</p><p>Besides being able to navigate to each individual module&#x27;s documentation page, or that of any individual predicate it contains, the web page generated by PlDoc has an icon on the right hand side to let you look at the source code, and another to let you edit the code by launching PceEmacs with the selected file loaded.</p><p>To see changes to the files, I just need to refresh the browser.</p><p>Back to the first stage of the design process: planning. Snoopy&#x27;s travails getting past the intro of the novel he is writing, a theme Charles Schulz often explored in his Peanuts cartoons, will strike a chord in anyone who has started any kind of creative project.</p><p></p><img src="/static/Snoopys-Dark-and-Stormy-Night-Second-Line.jpg" alt="Snoopy&#x27;s intro woes" embedtype="image" format="left" id="6"/><p></p><p>Rather than starting at the beginning as a reader would, the great novelist should be using a &quot;top-down design&quot; approach, starting with a summary of the overarching plot, then splitting that into chapters with what we&#x27;ll call a one-line purpose statement for each, only getting into nitty-gritty details such as character names and the intro after a blueprint has been drawn and the virtual scaffolding is in place.</p><p>&quot;The design of a program proceeds in a top-down planning phase followed by a bottom-up construction phase. We explicitly show how the interface to libraries dictates the shape of certain program elements. In particular, the very first phase of a program design yields a wish list of functions,&quot; <i>How to Design Programs</i> says in its preface.</p><p>But as another Snoopy cartoon illustrates, blindly following a recipe doesn&#x27;t necessarily improve things.</p><p></p><img src="/static/snoopy_composition.jpg" alt="Divide and conquer" embedtype="image" format="left" id="7"/><p>Moving from the analogy of writing novels to writing software applications, once we have broadly decided what we want to achieve — in my case a strategy game playing website <a href="http://www.newsgames.biz">newsgames.biz</a> — the SWI-Prolog equivalent of chapters is modules, which in SWI-Prolog&#x27;s case have interfaces which look like:</p><pre><code>:-module(module_name, 
    [ predicate1/arity1
    , predicate2/arity2
    , ...
    ]
).</code></pre><p>Writing this list of interfaces produces what <i>How to Design Programs</i> calls a wish list.</p><p>The <a href="https://www.swi-prolog.org/pldoc/man?section=usingmodules">section on modules</a> in the SWI-Prolog suggests a few of the advantages of interfaces. In terms of systematically designing software, a huge advantage of modularisation is it splits what at first appears to be an overwhelming task into manageable pieces and provides a todo list of how to proceed.</p><p>An advantage software developers have over novelists is well designed modules can be re-used in lots of projects. Better yet, we often find the &quot;chapter&quot; we are looking for has already been written by somebody else, and using open source software is not considered plagiarism.</p><h3>A simple example of a commented module file</h3><pre><code>:- module(htdp, [f2c/2]).

/** <module> Using the How to Design Programs recipe for SWI-Prolog with pldoc
* @author Robert Laing
* @version 0.1
* @see <https://htdp.org/2019-02-24/index.html>
*
* 30 August 2019
*/

/**
* f2c(+Fahrenheit:number, -Celsius:number) is det
*
* Converts Fahrenheit temperatures to Celsius or vice versa
*
* ~~~{.pl}
* f2c(32, C), assertion(C == 0.0).
* f2c(212, C), assertion(C == 100.0).
* f2c(-40, C), assertion(C == -40.0).
* ~~~
*/
f2c(Fahrenheit, Celsius) :-
    Celsius is ((5/9) * (Fahrenheit - 32)).</code></pre><p>PlDoc uses notation similar to Javadoc with comments starting with /** and ending with */, containing @tag commands which are used to format the HTML.</p><p>Note that the <i>file</i> comment needs to come after the module/2 declaration, else PlDoc won&#x27;t render it correctly.</p><p>The Javadoc style is an alternative to a more Prologish percent sign comment notation. I hop between SWI-Prolog and Javascript, whose jsdoc system also uses notation derived from Javadoc, so find it more convenient.</p><p>Saving the percent sign for comments which are just comments, and not supposed to be part of the automatically generated documentation, is also handy.</p><h2>Step 2: Fake it till you make it</h2><p><i>How To Design Progams</i> describes this second step as &quot;Signature, Purpose Statement, Header&quot;.</p><p>The textbook&#x27;s initial example, which I&#x27;ve translated into Prolog for this tutorial, looks like this:</p><pre><code>; Number -> Number
; converts Fahrenheit temperatures to Celsius
; given 32, expect 0
; given 212, expect 100
; given -40, expect -40
(define (f2c f)
    (* 5/9 (- f 32)))</code></pre><p>The above style of signature `Number -&gt; Number` reminds me of ML, a language I was introduced to by an excellent <a href="https://www.coursera.org/learn/programming-languages">online course</a> which stresses types and interfaces by not simply leaving signatures as something to be commented, but verbosely writes them out in Type1 * Type2 * ... -&gt; TypeR notation when running scripts.</p><p>This convention does not really work for Prolog considering predicates have one or more output parameters as opposed to functions which have a return value.</p><h3>Prolog signatures (declaration headers)</h3><p>PlDoc&#x27;s documentation has a section <a href="https://www.swi-prolog.org/pldoc/man?section=modes">Type, mode and determinism declaration headers</a> which sets out important conventions required to understand Prolog&#x27;s often terse documentation. In this example, the Prolog-style <i>declaration header</i> would look like this:</p><p><code>f2c(+Fahrenheit:number, -Celsius:number) is det</code></p><p>Sadly, there&#x27;s a lot in the above line to frustrate and confuse novices encountering Prolog for the first time who have not yet learned that these are documentation conventions, not actual coding syntax. What the prefix symbols along with <i>det, semidet, failure, nondet, and multi</i> mean are core concepts which should be upfront in a Prolog beginner tutorial, not burried in PlDoc&#x27;s documenation.</p><p>Without comments explaining what arguments represent, languages which do not require <i>hard typing</i> give few clues on how to use the provided code, even moreso languages where the convention is to use the shorthand of functor/arity.</p><p>I&#x27;m a bit vague as to how polymorphic arguments should be documented in Prolog. As far as I understand the example provided in the documentation</p><pre><code>%! length(+List:list, -Length:int) is det.
%! length(?List:list, -Length:int) is nondet.
%! length(?List:list, +Length:int) is det.
%
% True if List is a list of length Length.
%
% @compat iso</code></pre><p>a separate declaration header is written for each case.</p><p>If I wanted to change this simple example to be <i>bidirectional</i> — a nice thing about Prolog is it encourages symmetry — my guess would be to change the declaration header to:</p><p><code>f2c(?Fahrenheit:number, ?Celsius:number) is semidet</code></p><p>To implement this (which I shouldn&#x27;t be doing at this stage), I&#x27;d need to split this into three predicates;</p><p><code>f2c(+Fahrenheit:number, -Celsius:number) is det % Returns one Celsius value for provided Fahrenheit value</code></p><p><code>f2c(-Fahrenheit:number, +Celsius:number) is det % Returns one Fahrenheit value for provided Celsius value</code></p><p><code>f2c(+Fahrenheit:number, +Celsius:number) is semidet % Fails if input values have not been correctly calculated</code></p><p>My view is that overcomplicates the documentation for users who just need to know they can input either value, or both if they want to test a pre-calculated conversion.</p><h3>Purpose statements</h3><p>This is a short summary the PlDoc server will place next to the link to the predicate on the home page.</p><p>Note there is a blank comment line between the declaration header and the purpose statement.</p><p>In this case, it is rendered on the home page as:</p><p><code>f2c/2 Converts Fahrenheit temperatures to Celsius.</code></p><h3>Stubs</h3><p>The f2c example jumps the gun in that the predicate has already been completed. In a large project following a systematic design methodology, only something like</p><p><code>f2c(Fahrenheit, 0.0).</code></p><p>would be written as a placeholder at this stage to avoid a <b>ERROR: Undefined procedure: f2c/2 (DWIM could not correct goal)</b> as we build up our wish list with tests.</p><p>Loading the module file with the example stub would result in a red <b>Warning: Singleton variables: [Fahrenheit],</b> acting as a handy reminder this is a temporary placeholder.</p><h2>Step 3: Illustrate with examples</h2><p>The first thing most people look for in software documentation is examples of how to use an unfamiliar function. So one of the many advantages of <i>example-driven design</i> is it leaves good documentation in its wake.</p><p>Much as lawyers are trained to only ask witnesses questions they already know the answers to, the quality of code improves a lot if developers start by listing examples of what the correct output is for given input. This not only makes debugging easier later, it also shapes the developing code in a logical way.</p><p>Combining examples as documentation and tests with SWI-Prolog requires a bit of duplication since PlUnit and PlDoc are not integrated. An example of an integrated documentation and unit testing system would by Python&#x27;s pydoc, but it doesn&#x27;t make that much difference provided you remember to include some <i>illustrative examples</i> in your documentation.</p><p>Repeating how I&#x27;ve written my documentation for f2c again:</p><p><code>/**</code></p><p><code>* f2c(+Fahrenheit:number, -Celsius:number) is det</code></p><p><code>*</code></p><p><code>* Converts Fahrenheit temperatures to Celsius</code></p><p><code>*</code></p><p><code>* ~~~{.pl}</code></p><p><code>* f2c(32, C), assertion(C == 0.0).</code></p><p><code>* f2c(212, C), assertion(C == 100.0).</code></p><p><code>* f2c(-40, C), assertion(C == -40.0).</code></p><p><code>* ~~~</code></p><p><code>*/</code></p><p>A Google search revealed that <a href="http://wiki.c2.com/?AssertionsAsComments">Assertions As Comments</a> as actually not uncommon.</p><p></p><p>Running these assertions is done in a separate file, which I&#x27;ve called htdp.plt and looks like this:</p><pre><code>:- begin_tests(htdp).
:- use_module(['htdp.pl']).

test(f2c2) :-
    f2c(32, C),
    assertion(C == 0.0).

test(f2c1) :-
    f2c(212, C),
    assertion(C == 100.0).

test(f2c3) :-
    f2c(-40, C),
    assertion(C == -40.0).

:- end_tests(htdp).</code></pre><p>If I use the stub <code>f2c(Fahrenheit, 0.0).</code> in the module file rather than the completed predicate, I&#x27;d get the following test results:</p><p></p><img src="/static/terminal2.png" alt="Red, green, refactor" embedtype="image" format="left" id="8"/><p></p><p>Ideally, the <b>% 2 tests failed</b> line should be in red rather than green, but at least the error messages are red.</p><p>Test driven development is a form of gamification in that the <i>red, green, refactor</i> cycle turns getting the stub to work correctly into a fun challenge, eventually rewarded the player with an all green screen saying all tests past.</p><p></p><h2>Step 4: Expand stubs into skeletons or templates</h2><p>Googling <i>data-driven development</i> tends to bring up topics related to developing first-person shooter games with C++, which I think unfortunate since it obscures an important concept that programs &quot;are what they eat&quot;, and those that consume and produce the same types will be abstractly very similar.</p><p>A nifty trick I found doing the ML course was that given the input and output types for a given problem, simply finding a builtin function with the same signature and then using its code as a starting point made the homework assignments fairly easy. Though I&#x27;ve never done any university courses involving Prolog homework assignments, I&#x27;m pretty sure the same trick would work.</p><p>Here Prolog&#x27;s listing/1 predicate is invaluable. I was recently struggling with a <i>data munging</i> problem and managed to get going by using <code>listing(read_files_to_codes).</code> which provided this template to edit into what I wanted to do (and introduced me to setup_call_cleanup/3):</p><p></p><img src="/static/terminal3.png" alt="listing example" embedtype="image" format="left" id="9"/><p></p><p>&quot;Big picture&quot; predicates early in the design phase tend to involve a pipeline of data translations, which in turn involves expanding their stubs into wish lists of auxiliary or helper predicates, making this a <i>fractal</i> process involving lots of repeating the design steps on a smaller scale as you drill down.</p><h2>Step 5: Flesh out the skeletons</h2><p>I&#x27;m simply going to cut and paste from How to Design Programs here: &quot;It is now time to <i>code</i>. In general, to code means to program, though often in the narrowest possible way, namely, to write executable expressions and function definitions.</p><p>&quot;To us, coding means to replace the body of the function with an expression that attempts to compute from the pieces in the template what the purpose statement promises.&quot;</p><h2>Step 6: Turn all the red green</h2><p>For this simple example, it&#x27;s game won when we get to a screen that looks like this:</p><img src="/static/terminal4.png" alt="All green" embedtype="image" format="left" id="10"/><p>For a real-world big application, the red, green, refactor cycle would probably never end, with ever more features added and new bugs creeping in.</p>
