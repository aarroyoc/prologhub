<p>BEFORE TESTING, let’s structure our project. For this example we’ll diagnose an apple to see if it is good to eat. First we’ll setup our file structure, then we’ll add the content, and run the tests.</p><h2><i>Get Organised</i></h2><p>A STANDARD structure is to separate your knowledge base from your reasoning over it. This makes it easier to interchange your knowledge base. We’ll also keep our tests in their own file for the sake of readability.</p><p>Setup the following file structure, you can download the files to follow along:</p><p><code>project/<br/>|-- kb.pl</code> (<a id="1" linktype="document">PLUnit Example Knowledge Base</a>)<br/><code>|-- inference.pl</code> (<a id="2" linktype="document">PLUnit Example Inference Predicates</a>)<br/><code>|-- inference.plt</code> (<a id="3" linktype="document">PLUnit Example Inference Tests</a>)</p><p></p><p><code>kb.pl</code> holds the facts, data, knowledge, whatever you wish to call it. There’s no reasoning done in that file. <code>inference.pl</code> is our placeholder name for where you do your fancy work, reasoning, etc. <code>inference.plt</code> is the test file, <i>it</i> <b><i>must</i></b><i> have the same name as what you’re testing</i> for SWI-Prolog to automatically find it and load it. The only difference is the “<b>t</b>” on the end.</p><h3>Let&#x27;s look at the Prolog.</h3><p>Starting with <b><code>kb.pl</code></b>, there’s some rather glib information about apples. <code>ako</code> stands for “a kind of”, <code>isa</code> is the “is a” relationship, i.e. an instance of some class. We have some information on what an apple is, and a few different kinds of apples. We then have three instances of those apples, boringly called test_subjectN. To make thing’s fun, we also have a maggot called Maud, who’s living in one of the apples.</p><p></p><p>Then there&#x27;s <b><code>inference.pl</code></b>, this defines <code>ako</code> as a transitive relationship and makes <code>isa</code> smart too. From there I’ve just created some quick conditions to determine if an apple is edible. This is the file you’d run and query, the unit tests for it are in <b><code>inference.plt</code></b><b>.</b></p><h2>Running The Tests</h2><p>There are two ways to run them, from the swipl prompt, or command line. When running from the swipl prompt, if you’re still adding tests, include make(all) in the options so when you query <code>make.</code> it also makes your tests. If you’ve done with that you can omit it: <code>load_test_files([]).</code></p><p><code>bash:~/ $ swipl inference.pl<br/>Welcome to SWI-Prolog &lt;etc...&gt;<br/>?- load_test_files([make(all)]).<br/>true.<br/>?- run_tests.</code></p><p>From the command line you can call:</p><p><code>swipl -t &quot;load_test_files([]), run_tests.&quot; -s inference.pl</code><br/></p><p>This tell’s swipl to load the source file <code>inference.pl</code> and to run the tests as a top goal. I like to set an alias for easy testing, you can add the following to the end of your <code>.bashrc</code>, or set it locally, assuming you’re a fellow bash user.</p><p><code>alias plunit=&#x27;swipl -t &quot;load_test_files([]), run_tests.&quot; -s&#x27;</code></p><p>Now you can run the tests by simply typing:</p><p>plunit inference.pl</p><h2>Conclusion</h2><p>We&#x27;ve got unit tests in their own file, working with separate knowledge base and reasoning. Plus, we can run them very easily. I’ve not gone into detail about how to write unit tests or how to use plunit. The <a href="http://www.swi-prolog.org/pldoc/doc_for?object=section(%27packages/plunit.html%27)">docs</a> are actually not too difficult to follow once you’ve seen an example and got a setup running. Hopefully, this has been helpful enough to get you started!</p>